<template>
	<div style="height: 100%; width: 100%; background-size: 100% 100%;"></div>
</template>

<!--ThreeJS-->
<script src="js/three.min.js"></script>
<script src="js/ColladaLoader.js"></script>
<script src="js/Detector.js"></script>

<script>

	(function(window, document) {
		// Refers to the "importee", which is src/hello-world.html
		var componentDoc =  (document._currentScript || document.currentScript).ownerDocument;
		var componentDir = componentDoc.baseURI.substring(0, componentDoc.baseURI.lastIndexOf('/'));

		// Gets content from <template>
		var template = componentDoc.querySelector('template').content;

		// Creates an object based in the HTML Element prototype
		var ElementProto = Object.create(HTMLElement.prototype);

		// Fires when an instance of the element is created
		ElementProto.createdCallback = function() {
			var self = this;

			// get params from datastore-object element
			self.elementAttributes = {};
			for(var ctr = 0; ctr < this.attributes.length; ctr++) {
				self.elementAttributes[this.attributes[ctr].nodeName] = self.attributes[ctr].nodeValue;
			}

			// Creates the shadow root
			self.shadowRoot = self.createShadowRoot();

			// Adds a template clone into shadow root
			self.shadowRoot.appendChild(document.importNode(template, true));

			var threejsContainer = self.shadowRoot.querySelector('div');

			// set background color and/or image
			if(typeof self.elementAttributes['background-image'] === "string")
				threejsContainer.style['background-image'] = 'url("' + self.elementAttributes['background-image'] + '")';
			if(typeof self.elementAttributes['background-color'] === "string")
				threejsContainer.style['background-color'] = self.elementAttributes['background-color'];

			var outputCamera, outputScene, camera, scene, renderer, dae, texture;



			colladaLoad(self.elementAttributes.src, function(collada) {
				dae = collada;
				var containerWidth = 2048; //threejsContainer.offsetWidth;
				var containerHeight = 2048; //threejsContainer.offsetHeight;

				camera = new THREE.PerspectiveCamera(45, containerWidth / containerHeight, 1, 10000);
				scene = new THREE.Scene();

				scene.add(collada); // Add the COLLADA
				scene.add(new THREE.AmbientLight(0xcccccc)); // Let there be light

				// Adds some texture when rotating
				// TODO allow lights to be added as children of the master element
				var light = new THREE.SpotLight(0x757575, 1.5);
				light.position.set(1000, 1000, 2000);
				scene.add(light);

				// Scene to render to screen
				outputScene = new THREE.Scene();

				outputCamera = new THREE.OrthographicCamera(
						containerWidth / -2, // left
						containerWidth / 2, // right
						containerHeight / 2, // top
						containerHeight / -2, // bottom
						0, // frustum near plane.
						1 // frustum far plane.
				);

				var plane = new THREE.PlaneBufferGeometry(containerWidth, containerHeight);
				texture = new THREE.WebGLRenderTarget(containerWidth, containerHeight, {format: THREE.RGBAFormat, minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter});
				var material = new THREE.MeshLambertMaterial({map : texture, opacity: 1});

				outputScene.add(new THREE.Mesh(plane, material));
				outputScene.add(new THREE.AmbientLight(0xffffff));

				renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.autoClear = false;
				renderer.setSize(containerWidth, containerHeight);

				threejsContainer.appendChild(renderer.domElement);

				window.addEventListener('resize', onWindowResize, false);

				animate();
			});

			function colladaLoad(src, callback) {
				var loader = new THREE.ColladaLoader();
				loader.options.convertUpAxis = true;
				loader.load(src, function(collada) {
					collada.scene.traverse(function (child) {
						if(child instanceof THREE.SkinnedMesh) {
							var animation = new THREE.Animation(child, child.geometry.animation);
							animation.play();
						}
					});

					collada.scene.scale.x = collada.scene.scale.y = collada.scene.scale.z = 2;
//					object3.updateMatrix();

					collada.scene.updateMatrix();
					callback(collada.scene);

				});
			}

			function onWindowResize() {
				camera.aspect = threejsContainer.offsetWidth / threejsContainer.offsetHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( threejsContainer.offsetWidth, threejsContainer.offsetHeight );
			}

			function animate() {
				requestAnimationFrame(animate);
				render();
			}

			var clock = new THREE.Clock();

			function render() {
				dae.position.x = self.elementAttributes.objectpositionx;
				dae.position.y = self.elementAttributes.objectpositiony;
				dae.position.z = self.elementAttributes.objectpositionz;

//				dae.scale.x = dae.scale.y = dae.scale.z = 0.02;

				dae.rotation.x = degreesToRadians(self.elementAttributes.objectrotationx);
				dae.rotation.y = degreesToRadians(self.elementAttributes.objectrotationy);
				dae.rotation.z = degreesToRadians(self.elementAttributes.objectrotationz);

/*				camera.position.x = self.elementAttributes.camerapositionx;
				camera.position.y = self.elementAttributes.camerapositiony;
				camera.position.z = self.elementAttributes.camerapositionz;

				camera.rotation.x = degreesToRadians(self.elementAttributes.camerarotationx);
				camera.rotation.y = degreesToRadians(self.elementAttributes.camerarotationy);
				camera.rotation.z = degreesToRadians(self.elementAttributes.camerarotationz);


				//var timer = Date.now() * 0.00001;
				//console.log(timer);

				camera.lookAt({x: self.elementAttributes.lookx, y: self.elementAttributes.looky, z: self.elementAttributes.lookz});
/*
				console.log(camera.rotation.y);

				camera.position.x = Math.cos(timer) * 35;
				camera.position.y = 2;
				camera.position.z = Math.sin(timer) * 35;
*/
//				camera.rotation.x = degreesToRadians(self.elementAttributes.rotx);
//				camera.rotation.y = degreesToRadians(self.elementAttributes.roty);
//				camera.rotation.z = degreesToRadians(self.elementAttributes.rotz);

				THREE.AnimationHandler.update( clock.getDelta() );
				renderer.render(scene, camera, texture, true);
				renderer.render(outputScene, outputCamera);

//				renderer.render(scene, camera);

			}
		};

		// Fires when an attribute was added, removed, or updated
		ElementProto.attributeChangedCallback = function(attr, oldVal, newVal) {
			// TODO when some camera value changes, step out of active view
			this.elementAttributes[attr] = newVal;
		};

		function degreesToRadians(degrees) {
			return degrees * (Math.PI / 180);
		}

		window.DatastoreObject = document.registerElement('datastore-object', {
			prototype: ElementProto
		});
	})(window, document);
</script>
